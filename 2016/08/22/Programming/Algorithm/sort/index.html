<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>排序算法 | Daemon.D.Blog</title><meta name="author" content="DaemondShu"><meta name="copyright" content="DaemondShu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这里列举一下常见排序算法的对比。个人觉得相对重要需要会手写的排序算法还是快速、归并、堆排序、插入，以及借助桶(基数)排序了解桶的思想。其他排序不常用，就是了解概念即可。 冒泡 Bubble Sort 说明 相邻元素的比较和交换来把小的数交换到最前面，过程类似水泡上升  举例： 原始5,3,8,6,4，每一轮都是遍历N-1个元素，然后比较相邻元素，按大小关系交换，如下展示从尾部遍历的第一轮的过程"><meta property="og:type" content="article"><meta property="og:title" content="排序算法"><meta property="og:url" content="http://daemondshu.github.io/2016/08/22/Programming/Algorithm/sort/index.html"><meta property="og:site_name" content="Daemon.D.Blog"><meta property="og:description" content="这里列举一下常见排序算法的对比。个人觉得相对重要需要会手写的排序算法还是快速、归并、堆排序、插入，以及借助桶(基数)排序了解桶的思想。其他排序不常用，就是了解概念即可。 冒泡 Bubble Sort 说明 相邻元素的比较和交换来把小的数交换到最前面，过程类似水泡上升  举例： 原始5,3,8,6,4，每一轮都是遍历N-1个元素，然后比较相邻元素，按大小关系交换，如下展示从尾部遍历的第一轮的过程"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://daemondshu.github.io/images/bg/next_size.png"><meta property="article:published_time" content="2016-08-21T16:00:00.000Z"><meta property="article:modified_time" content="2016-08-21T16:00:00.000Z"><meta property="article:author" content="DaemondShu"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://daemondshu.github.io/images/bg/next_size.png"><link rel="shortcut icon" href="/images/logo/favicon-32x32.png"><link rel="canonical" href="http://daemondshu.github.io/2016/08/22/Programming/Algorithm/sort/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: DaemondShu","link":"Link: ","source":"Source: Daemon.D.Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"排序算法",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2016-08-22 00:00:00"}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/butterfly_common.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/user_256px.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Daemon.D.Blog"><span class="site-name">Daemon.D.Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">排序算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2016-08-21T16:00:00.000Z" title="Created 2016-08-22 00:00:00">2016-08-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2016-08-21T16:00:00.000Z" title="Updated 2016-08-22 00:00:00">2016-08-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Programming/">Programming</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Programming/Algorithm/">Algorithm</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><p>这里列举一下常见排序算法的对比。<br>个人觉得相对重要需要会手写的排序算法还是快速、归并、堆排序、插入，以及借助桶(基数)排序了解桶的思想。<br>其他排序不常用，就是了解概念即可。</p><h2 id="冒泡-Bubble-Sort"><a href="#冒泡-Bubble-Sort" class="headerlink" title="冒泡 Bubble Sort"></a>冒泡 Bubble Sort</h2><ul><li>说明<ul><li><p>相邻元素的比较和交换来把小的数交换到最前面，过程类似水泡上升</p></li><li><p>举例： 原始5,3,8,6,4，每一轮都是遍历N-1个元素，然后比较相邻元素，按大小关系交换，如下展示从尾部遍历的第一轮的过程</p><ol><li>46比较： 5,3,8,4,6</li><li>84比较： 5,3,4,8,6</li><li>…</li><li>第一轮结束： 3,5,4,8,6</li></ol><p>如此反复遍历全数据比较，直至某一轮没法发生交换即排序完成。</p></li></ul></li><li>复杂度<ul><li>最好： O(n) 原本有序，一轮结束</li><li>最差，平均： O($n^2$)</li></ul></li></ul><h3 id="梳排序-comb-sort"><a href="#梳排序-comb-sort" class="headerlink" title="*梳排序 comb sort"></a>*梳排序 comb sort</h3><p>改进了冒泡排序，改进思想与下文希尔排序类似<br>比较少用，暂时不在这里说明了<br>复杂度有所改进，有兴趣可自己查阅其他资料，如<a target="_blank" rel="noopener" href="https://www.yiibai.com/data_structure/comb-sort.html">梳排序 - 易百教程</a></p><h2 id="选择-Selection-Sort"><a href="#选择-Selection-Sort" class="headerlink" title="选择 Selection Sort"></a>选择 Selection Sort</h2><ul><li>说明<br>每次选使得一个元素找到他应该所在的次序位置。<br>每一趟在剩余元素中选择最值，将其交换至应该存在的位置，直到所有元素排序完成。<br>保证第i轮结束后，前i个元素有序</li><li>复杂度<ul><li>最好、最差、平均：O($n^2$)</li><li>但是一般性能优于冒泡，因为选择排序每一轮至多有一次交换，即最多n次交换，而冒泡交换是O($n^2$)级别的</li></ul></li></ul><h2 id="插入-Insertion-Sort"><a href="#插入-Insertion-Sort" class="headerlink" title="插入 Insertion Sort"></a>插入 Insertion Sort</h2><ul><li><p>说明<br>基本操作是将一个元素插入到已经有序的数列中，从而得到一个新的有序数列<br>实质是用增量排序操作去解决定量排序问题</p></li><li><p>复杂度</p><ul><li>最好: O(n) 原本有序</li><li>最差、平均: O($n^2$)</li></ul></li></ul><h3 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h3><p>靠二分去定位要插入的位置，但是后续多个元素的位移，仍旧是O(n)级别的操作<br>复杂度类似</p><h3 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序 Shell Sort"></a>希尔排序 Shell Sort</h3><p>基本思想是将相距某个增量gap的记录组成一个子序列，通过插入排序使得这个子序列基本有序。然后不断缩小gap，gap以不断折半为规则。 总体复杂度为<br>图解如下：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2016/08/22/Programming/Algorithm/sort/ss_1.png" loading="lazy"></p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>复杂度最终说法不一，可以明确的是 在O(N)和O(logN)之间，但是有些说是 O($n^{1.3}$) ，有些说是接近于O($NlogN$)， 我还没研究证明过</p><h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 Quick Sort"></a>快速排序 Quick Sort</h2><p><strong>最常见</strong>的排序算法，各大基础库内置的基本都是这个算法。<br>采用分治思想，每次递归时选择一个点作为当前区间内的中点，将小于该中点的值放入左子树，大于该中点的放入右子树，然后继续对左子树和右子树进行相同的操作。 步骤描述如下：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h3 id="几种实现方法"><a href="#几种实现方法" class="headerlink" title="几种实现方法"></a>几种实现方法</h3><p>实现的时候对于第2步的实现，有些trick的地方，直接按这个意思写写出来的代码性能会稍差，高效实现可以参看如下代码（均以顺序排序为例）：<br>下面代码中left和right都是指有效索引，即<code>vec[left]</code>和和<code>vec[right]</code>都有值</p><ul><li><p>取端点pivot的填充法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;T&gt; &amp;vec, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1 </span></span><br><span class="line">  T pivot = vec[left]; <span class="comment">//提出枢纽，这时left位置空出来了。</span></span><br><span class="line">  <span class="type">int</span> i = left, j = right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;<span class="comment">//注意两个内层while的顺序不能换</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; j &amp;&amp; vec[j] &gt;= pivot) j--; <span class="comment">//这里是&gt;=不能使&gt;，否则当数组元素等于枢纽时会死循环</span></span><br><span class="line">      vec[i] = vec[j];<span class="comment">//将找到的小于于枢纽的元素存到j所指的空穴，这时j位置空出来了</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; j &amp;&amp; vec[i] &lt;= pivot) i++; <span class="comment">//这里是&lt;=不能使&lt;，否则当数组元素等于枢纽时会死循环</span></span><br><span class="line">      vec[j] = vec[i];<span class="comment">//将找到的大于枢纽的元素存到j所指的空穴，这时i位置空出来了</span></span><br><span class="line">  &#125;</span><br><span class="line">  vec[i] = pivot;</span><br><span class="line">  <span class="type">int</span> pivot_pos = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; pivot_pos - <span class="number">1</span>) <span class="built_in">QuickSort</span>(vec, left, pivot_pos - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (right &gt; pivot_pos + <span class="number">1</span>) <span class="built_in">QuickSort</span>(vec, pivot_pos + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Hoare交换法（以pivot中点为例）<br>减少了交换次数，效率更高</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;T&gt; &amp;vec, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"> T pivot = vec[(left + right) / <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"> <span class="type">int</span> i = left;</span><br><span class="line"> <span class="type">int</span> j = right;</span><br><span class="line"> <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">     <span class="keyword">while</span> (vec[i] &lt; pivot) i++; <span class="comment">// 从左找到一个&gt;=pivot的元素</span></span><br><span class="line">     <span class="keyword">while</span> (vec[j] &gt; pivot) j--; <span class="comment">// 从右找到一个&lt;=pivot的元素</span></span><br><span class="line">     <span class="keyword">if</span> (i &lt;= j) <span class="comment">// 交换两者位置</span></span><br><span class="line">         <span class="built_in">swap</span>(vec[i++], vec[j--]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 3</span></span><br><span class="line"> <span class="keyword">if</span> (left &lt; j)  <span class="built_in">QuickSort</span>(vec, left, j);</span><br><span class="line"> <span class="keyword">if</span> (i &lt; right) <span class="built_in">QuickSort</span>(vec, i, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>快排存在一定的随机性，主要来源于中点值的选择，</p><ul><li>最好情况O(NlogN)： 中点能平衡左右子树元素个数（选取的中点接近实际中点），那么属于最好情况</li><li>最差情况O($N^2$)： 中点划分出的左右子树元素非常不平衡，如刚好选择了最大值或者最小值。会导致随着深度增加，元素规模只会逐个减少。<ul><li>如果每次选取端点为中点，那么对于完全逆序的情况，就是最差情况。</li><li>选用随机基准法可以降低最差情况的概率</li></ul></li><li>平均O(NlogN)</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="*优化"></a>*优化</h3><ul><li>大规模下针对pivot选择做优化<ul><li>比如<code>三位取中法</code>， 从 数组左端，中断，右端选取一个中间大小的值，来提升中点能平衡左右个数的概率</li></ul></li><li>小规模下换其他算法<ul><li>因为递归调用和分割开销较大，可用插入排序代替</li></ul></li><li>3-way 特殊场景优化 相同的值做合并，每次划分，分成三个集合， 小于中点的集合，等于中点的集合，大于中点的集合<ul><li>如对于1 4 6 6 7 6 7 6 8 6 数组， 如果选取最右的6为中点，那么一轮划分后为 1 4 和 6 6 6 6 6 和 7 8 7</li></ul></li><li>双轴心快排 <code>DualPivotQuicksort</code><ul><li><strong>Java Arrays.sort的标准实现java.util.DualPivotQuicksort</strong></li><li>个人认为是泛化了相同的值做合并，并结合小规模换插入排序</li><li>大规模下每次设置两个轴点，分成3块 ，小规模下做插入排序，</li><li>有兴趣可以阅读<a target="_blank" rel="noopener" href="https://github.com/frohoff/jdk8u-dev-jdk/blob/master/src/share/classes/java/util/DualPivotQuicksort.java">源码</a>。</li></ul></li><li>多线程下的快排优化<ul><li>TODO</li></ul></li></ul><p>我目前理解不够，以后有时间单独开一篇文章来讲快排各种优化与适用场景的理论和测试对比。</p><h2 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序 Heap Sort"></a>堆排序 Heap Sort</h2><p>借助堆不断输出堆顶元素来实现排序</p><h3 id="堆结构-（优先队列）"><a href="#堆结构-（优先队列）" class="headerlink" title="堆结构 （优先队列）"></a>堆结构 （优先队列）</h3><p>堆是一棵完全二叉树，要求树根就是所有元素中的最值。以大根堆为例，要求对于任意节点，其值 ≤ 左子树的值和右子树的值，即任意节点是其所在子树的最值。如下图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2016/08/22/Programming/Algorithm/sort/big_heap.png" loading="lazy"><br>常以<code>树状数组</code>存储，若数组索引以1开始,则对应要求可以书写为 a[i] &gt;&#x3D; a[i * 2], a[i] &gt;&#x3D; a[i*2]。如下图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2016/08/22/Programming/Algorithm/sort/heap_array.png" loading="lazy"></p><h4 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h4><blockquote><p>以下 <code>*2</code> <code>/2</code>操作建议用位移操作加速，在这里为了方便理解就不用位移操作取代了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item *data;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MaxHeap</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity+<span class="number">1</span>]; count = <span class="number">0</span>;<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MaxHeap</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MaxHeap</span>(Item arr[], <span class="type">int</span> n);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>;</span><br><span class="line">    <span class="function">Item <span class="title">extract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他有关于获取顶端、获取count操作就不列举了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加元素-O-logN"><a href="#添加元素-O-logN" class="headerlink" title="添加元素 O(logN)"></a>添加元素 O(logN)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeap::insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>( count + <span class="number">1</span> &lt;= capacity );</span><br><span class="line">    data[++count] = item;</span><br><span class="line">    <span class="comment">//通过shiftup保持堆的定义</span></span><br><span class="line">    <span class="built_in">shiftUp</span>(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将位置k的元素尝试向根移动，不断替换比自己小的父亲节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeap::shiftUp</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k] )&#123;</span><br><span class="line">        <span class="built_in">swap</span>( data[k/<span class="number">2</span>], data[k] );</span><br><span class="line">        <span class="comment">//交换过之后考虑当前节点，就是上次节点交换后的位置</span></span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="弹出顶端元素-O-logN"><a href="#弹出顶端元素-O-logN" class="headerlink" title="弹出顶端元素 O(logN)"></a>弹出顶端元素 O(logN)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Item MaxHeap::  <span class="built_in">extract</span>()&#123;</span><br><span class="line">    <span class="built_in">assert</span>( count &gt; <span class="number">0</span> );</span><br><span class="line">    Item ret = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一个元素和第一个元素进行互换</span></span><br><span class="line">    <span class="built_in">swap</span>( data[<span class="number">1</span>] , data[count] );</span><br><span class="line">    count --;</span><br><span class="line">    <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根向下不断替换比自己大的 且 最大的子节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否有左孩子存在孩子的判定</span></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count )&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span>*k; <span class="comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">        <span class="comment">//有右孩子并且右孩子大于左孩子</span></span><br><span class="line">        <span class="keyword">if</span>( j+<span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j] )</span><br><span class="line">            <span class="comment">//因为右孩子更大，所以将j更新为j+1</span></span><br><span class="line">            j ++;</span><br><span class="line">        <span class="comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( data[k] &gt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>( data[k] , data[j] );</span><br><span class="line">        <span class="comment">//新的变到了j的位置</span></span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="初始化-O-n"><a href="#初始化-O-n" class="headerlink" title="初始化 O(n)"></a>初始化 O(n)</h4><p>对于所有非叶子节点做shiftDown</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MaxHeap::<span class="built_in">MaxHeap</span>(Item arr[], <span class="type">int</span> n)&#123;</span><br><span class="line">       data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">       capacity = n;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">           data[i+<span class="number">1</span>] = arr[i]; <span class="comment">//下标从1开始</span></span><br><span class="line">       count = n;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>( <span class="type">int</span> i = count/<span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i -- )</span><br><span class="line">           <span class="built_in">shiftDown</span>(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>误区： 不要以为N&#x2F;2次shiftDown复杂度就是O(NlogN)，因为不同层的运算次数不一样，可以做如下证明</li><li>复杂度证明：总高度为$h&#x3D;logN$，第x层元素的计算量为$2^x * (h-x)$<br>$S &#x3D; 2^{h-1} × 1 + 2^{h-2} × 2 + …… + 1 × (h-1) &#x3D; 2^h × 1 - h +1 &#x3D; N -logN +1 &#x3D; O(N)$</li></ul><h3 id="如何排序"><a href="#如何排序" class="headerlink" title="如何排序"></a>如何排序</h3><p>就是初步初始化后，然后不断extract。第i次extract的数就是第i大的数，就完成了排序。</p><p>其实堆常见的不是用在排序，更多是用在动态维护最值的场合，作为优先队列，比如多个有序数列合并(多路归并)、dijstra的堆优化。</p><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li><p>最好、最差、平均： O(NlogN) 即与快排相比，堆排<strong>没有最好最坏情况</strong>，每个情况都差不多。</p></li><li><p>为什么一般比快排慢： 几乎没有最好情况。在堆排序的时候，每次extract总是将堆顶元素移除，然后将最后的元素放到堆顶，再让其自我调整。这两个元素往往差距很大，所以每轮的调整次数几乎每次都就近于高度。</p></li></ul><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h2><p>这个思路是最简单的，是将排序分而治之的最直观算法，就是每次划分时保证左右子树个数接近甚至相等。 常用的 2 路归并排序假设初始序列有 n 个元素，可以看成是 n 个长度为 1 的子序列，进行两两归并，可以得到 n &#x2F; 2 个长度为 2 或 1 的子序列；再两两归并，直到得到一个长度为 n 的有序序列为止。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>以下是便于理解的递归版本实现，每次将当前数组拆成两等分, 每一等分自己先完成排序，然后再通过merge操作将两个有序子序列成一个大的有序序列。<br>(在下面的代码中，end是无效索引，最后一个元素是A[end-1])</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = (mid - start);</span><br><span class="line">    <span class="type">int</span> n2 = (end - mid);</span><br><span class="line">    <span class="type">int</span> L[n1], R[n2];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(L, &amp;A[start], <span class="built_in">sizeof</span>(<span class="type">int</span>) * n1);</span><br><span class="line">    <span class="built_in">memcpy</span>(R, &amp;A[mid], <span class="built_in">sizeof</span>(<span class="type">int</span>) * n2);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = start; k &lt; end; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= n2 || (i &lt; n1 &amp;&amp; L[i] &lt;= R[j]))</span><br><span class="line">            A[k] = L[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k] = R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergesort</span>(A, start, mid);</span><br><span class="line">        <span class="built_in">mergesort</span>(A, mid, end);</span><br><span class="line">        <span class="built_in">merge</span>(A, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>最好、最差、平均： O(NlogN)</li><li>为什么一般比快排慢：需要额外的空间做<strong>数组复制</strong>，额外空间复杂度为O(N)</li></ul><h3 id="归并排序相关问题"><a href="#归并排序相关问题" class="headerlink" title="归并排序相关问题"></a>归并排序相关问题</h3><ul><li>题目小练<ul><li>逆序对个数统计 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-pairs/">LeetCode 493 Reverse Pairs</a></li></ul></li></ul><h2 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h2><p>不基于比较，与其说像排序，更不如说像统计。都是拿空间换时间的策略，只适合元素范围较小的场合。</p><h3 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序 Counting Sort"></a>计数排序 Counting Sort</h3><p>统计每个元素出现个数，然后按元素从小到大遍历输出。<br>复杂度O(N+M), M是元素大小的范围(MAX-MIN)</p><h3 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序 Bucket Sort"></a>桶排序 Bucket Sort</h3><p>是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。</p><ul><li>平均时间复杂度为线性的O(N+C), C为桶内快排的时间复杂度。</li><li>如果刚好所有数据到一个桶里了，就是最差情况</li></ul><h3 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序 Radix Sort"></a>基数排序 Radix Sort</h3><p>可以理解多级桶排序，基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。<br>过程：</p><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ol><p>演示：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2016/08/22/Programming/Algorithm/sort/radix_sort.gif" loading="lazy"></p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><ul><li><p>定义： 待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]&#x3D;r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</p></li><li><p>稳定算法：<br>基数（桶）、冒泡、插入、归并</p></li><li><p>不稳定算法<br>快速、堆、希尔、选择</p></li></ul><h2 id="证明基于比较的排序复杂度不可能低于O-NlogN"><a href="#证明基于比较的排序复杂度不可能低于O-NlogN" class="headerlink" title="证明基于比较的排序复杂度不可能低于O(NlogN)"></a>证明基于比较的排序复杂度不可能低于O(NlogN)</h2><p>所有基于<strong>比较</strong>的排序算法，都可以抽象成一个决策数模型，为一个完全二叉树。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2016/08/22/Programming/Algorithm/sort/sort_prove.png" loading="lazy"><br>N个数的原始排列情况一共$n!$种情况，那么这棵能区分这$n!$种情况的决策树深度<br>$$ h \geq log(n!)$$<br>由于斯特林公式<br>$$n! \approx \sqrt{2\pi n}, \left(\frac{n}{e}\right)^{n} $$<br>最后得出<br>$$h \geq log(\sqrt{2\pi n}, \left(\frac{n}{e}\right)^{n} ) &#x3D; log(\sqrt{2\pi n}) + nlog(n&#x2F;e) &#x3D; O(nlogn)$$</p><h2 id="最后小小的总结"><a href="#最后小小的总结" class="headerlink" title="最后小小的总结"></a>最后小小的总结</h2><table><thead><tr><th>排序算法</th><th align="center">空间复杂度(平均)</th><th align="center">时间复杂度（平均）</th><th align="center">时间复杂度（最坏）</th><th align="center">时间复杂度（最好）</th><th align="center">是否稳定</th></tr></thead><tbody><tr><td>冒泡</td><td align="center">$O(1)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td>选择</td><td align="center">$O(1)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">不稳定</td></tr><tr><td>(直接)插入</td><td align="center">$O(1)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n^2)$</td><td align="center">稳定</td></tr><tr><td>希尔</td><td align="center">$O(1)$</td><td align="center">$O(n^{1.3})$</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">不稳定</td></tr><tr><td>快速</td><td align="center">$O(logn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(n^2)$</td><td align="center">$O(nlogn)$</td><td align="center">不稳定</td></tr><tr><td>归并</td><td align="center">$O(n)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">稳定</td></tr><tr><td>堆</td><td align="center">$O(1)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">$O(nlogn)$</td><td align="center">不稳定</td></tr><tr><td>计数</td><td align="center">$O(n+k)$</td><td align="center">$O(n+k)$</td><td align="center">$O(n+k)$</td><td align="center">$O(n+k)$</td><td align="center">稳定</td></tr><tr><td>桶</td><td align="center">$O(n+k)$</td><td align="center">$O(n+k)$</td><td align="center">$O(n^2)$</td><td align="center">$O(n)$</td><td align="center">稳定</td></tr><tr><td>基数</td><td align="center">$O(n+k)$</td><td align="center">$O(n*k)$</td><td align="center">$O(n*k)$</td><td align="center">$O(n*k)$</td><td align="center">稳定</td></tr></tbody></table><p>对于非比较排序，空间复杂度存在争议，因为有些排序在桶内会额外存储原值，有些不存。该表中空间复杂度是针对存原值的。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://www.codeproject.com/Articles/1023591/Cplusplus-Implementations-of-Quicksort-Methods-for">C++ Implementations of Quicksort Methods for Sorting Arrays with Lots of Duplicates</a><br><a target="_blank" rel="noopener" href="http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1">面试10大排序算法总结</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34421623">九种排序算法的可视化及比较</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解排序算法(二)之希尔排序</a><br><a target="_blank" rel="noopener" href="https://www.kancloud.cn/digest/pieces-algorithm/163612">快速排序的几种常见实现及其性能对比 - 点滴算法</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1114673">算法与数据结构（四）堆排序：优先队列实现 - 腾讯云社区</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/articles/7674659.html">十大经典排序算法（动图演示）</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://daemondshu.github.io">DaemondShu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://daemondshu.github.io/2016/08/22/Programming/Algorithm/sort/">http://daemondshu.github.io/2016/08/22/Programming/Algorithm/sort/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/bg/next_size.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2017/02/20/System%20Design/Distributed%20System/basic/" title="分布式系统基础之常见评价指标"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/bg/next_size.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">分布式系统基础之常见评价指标</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/user_256px.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">DaemondShu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1-Bubble-Sort"><span class="toc-number">1.</span> <span class="toc-text">冒泡 Bubble Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A2%B3%E6%8E%92%E5%BA%8F-comb-sort"><span class="toc-number">1.1.</span> <span class="toc-text">*梳排序 comb sort</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-Selection-Sort"><span class="toc-number">2.</span> <span class="toc-text">选择 Selection Sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-Insertion-Sort"><span class="toc-number">3.</span> <span class="toc-text">插入 Insertion Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5"><span class="toc-number">3.1.</span> <span class="toc-text">折半插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-Shell-Sort"><span class="toc-number">3.2.</span> <span class="toc-text">希尔排序 Shell Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.2.1.</span> <span class="toc-text">复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quick-Sort"><span class="toc-number">4.</span> <span class="toc-text">快速排序 Quick Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">几种实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">4.2.</span> <span class="toc-text">复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.</span> <span class="toc-text">*优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-Heap-Sort"><span class="toc-number">5.</span> <span class="toc-text">堆排序 Heap Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%BB%93%E6%9E%84-%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">堆结构 （优先队列）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-O-logN"><span class="toc-number">5.1.2.</span> <span class="toc-text">添加元素 O(logN)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B9%E5%87%BA%E9%A1%B6%E7%AB%AF%E5%85%83%E7%B4%A0-O-logN"><span class="toc-number">5.1.3.</span> <span class="toc-text">弹出顶端元素 O(logN)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-O-n"><span class="toc-number">5.1.4.</span> <span class="toc-text">初始化 O(n)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%92%E5%BA%8F"><span class="toc-number">5.2.</span> <span class="toc-text">如何排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">5.3.</span> <span class="toc-text">复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Merge-Sort"><span class="toc-number">6.</span> <span class="toc-text">归并排序 Merge Sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-number">6.2.</span> <span class="toc-text">复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">6.3.</span> <span class="toc-text">归并排序相关问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">非比较排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-Counting-Sort"><span class="toc-number">7.1.</span> <span class="toc-text">计数排序 Counting Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F-Bucket-Sort"><span class="toc-number">7.2.</span> <span class="toc-text">桶排序 Bucket Sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-Radix-Sort"><span class="toc-number">7.3.</span> <span class="toc-text">基数排序 Radix Sort</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">8.</span> <span class="toc-text">稳定性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%81%E6%98%8E%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8D%E5%8F%AF%E8%83%BD%E4%BD%8E%E4%BA%8EO-NlogN"><span class="toc-number">9.</span> <span class="toc-text">证明基于比较的排序复杂度不可能低于O(NlogN)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E5%B0%8F%E5%B0%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">最后小小的总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">11.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/16/System%20Design/Distributed%20System/consistency_model/" title="Consistency Model Summary in Distributed System">Consistency Model Summary in Distributed System</a><time datetime="2022-10-15T16:00:00.000Z" title="Updated 2022-10-16 00:00:00">2022-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/21/Programming/Java/ModernGC/" title="JVM GC(2) | Modern Garbage Collectors - CMS, G1, ZGC, Shenandoah GC">JVM GC(2) | Modern Garbage Collectors - CMS, G1, ZGC, Shenandoah GC</a><time datetime="2022-05-20T16:00:00.000Z" title="Updated 2022-05-21 00:00:00">2022-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/20/System%20Design/Distributed%20System/cache_overview/" title="Get Started with Cache">Get Started with Cache</a><time datetime="2022-02-19T16:00:00.000Z" title="Updated 2022-02-20 00:00:00">2022-02-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/08/20/System%20Design/Distributed%20System/distributed_transcation/" title="Distributed Transaction - 2PC, 3PC">Distributed Transaction - 2PC, 3PC</a><time datetime="2021-08-19T16:00:00.000Z" title="Updated 2021-08-20 00:00:00">2021-08-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/04/05/Storage/Database/Database_Transaction/" title="Database Transaction - ACID &amp; Isolation Level">Database Transaction - ACID &amp; Isolation Level</a><time datetime="2021-06-09T16:00:00.000Z" title="Updated 2021-06-10 00:00:00">2021-06-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2023 By DaemondShu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'DaemondShu/DaemondShu.github.io',
      'data-repo-id': 'MDEwOlJlcG9zaXRvcnkxNzYxMjUzNDI=',
      'data-category-id': 'DIC_kwDOCn91ns4CTWjW',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>